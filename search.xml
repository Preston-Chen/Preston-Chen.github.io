<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[Nuts & Bolts Problem]]></title>
      <url>/2018/05/29/Nuts%20&amp;%20Bolts%20Problem/</url>
      <content type="html"><![CDATA[<p><img src="http://oj8x3nb07.bkt.clouddn.com/Blog/Nuts%20&amp;%20Bolts%20Problem.jpg" alt=""></p>
]]></content>
      
        <categories>
            
            <category> Two Pointer </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Rotate String]]></title>
      <url>/2018/05/20/Rotate%20String/</url>
      <content type="html"><![CDATA[<p><img src="http://oj8x3nb07.bkt.clouddn.com/Blog/Rotate%20String.jpg" alt=""></p>
]]></content>
      
        <categories>
            
            <category> Binary Search </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Recover Rotated Sorted Array]]></title>
      <url>/2018/05/20/Recover%20Rotated%20Sorted%20Array/</url>
      <content type="html"><![CDATA[<p><img src="http://oj8x3nb07.bkt.clouddn.com/Blog/Recover%20Rotated%20Sorted%20Array.jpg" alt=""></p>
]]></content>
      
        <categories>
            
            <category> Binary Search </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Total Occurence of Target]]></title>
      <url>/2018/05/19/Total%20Occurence%20of%20Target/</url>
      <content type="html"><![CDATA[<p><img src="http://oj8x3nb07.bkt.clouddn.com/Blog/Total%20Occurence%20of%20Target.jpg" alt=""></p>
]]></content>
      
        <categories>
            
            <category> Binary Search </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Divide Two Integers]]></title>
      <url>/2018/05/13/Divide%20Two%20Integers/</url>
      <content type="html"><![CDATA[<p><img src="http://oj8x3nb07.bkt.clouddn.com/Blog/Divide%20Two%20Integers.jpg" alt=""></p>
]]></content>
      
        <categories>
            
            <category> Binary Search </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Search for a Range]]></title>
      <url>/2018/05/12/Search%20for%20a%20Range/</url>
      <content type="html"><![CDATA[<p><img src="http://oj8x3nb07.bkt.clouddn.com/Blog/Search%20for%20a%20Range.jpg" alt=""></p>
]]></content>
      
        <categories>
            
            <category> Binary Search </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[wood-cut]]></title>
      <url>/2018/05/06/wood-cut/</url>
      <content type="html"><![CDATA[<p><img src="http://oj8x3nb07.bkt.clouddn.com/Blog/wood-cut.jpg" alt=""></p>
]]></content>
      
        <categories>
            
            <category> Binary Search </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[First Bad Version]]></title>
      <url>/2018/05/05/First%20Bad%20Version/</url>
      <content type="html"><![CDATA[<p><img src="http://oj8x3nb07.bkt.clouddn.com/Blog/First%20Bad%20Version.jpg" alt=""></p>
]]></content>
      
        <categories>
            
            <category> Binary Search </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Sqrt(x)]]></title>
      <url>/2018/04/29/Sqrt(x)/</url>
      <content type="html"><![CDATA[<p><img src="http://oj8x3nb07.bkt.clouddn.com/Blog/Sqrt%28x%29.jpg" alt=""></p>
]]></content>
      
        <categories>
            
            <category> Binary Search </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Search in Rotated Sorted Array]]></title>
      <url>/2018/04/28/Search%20in%20Rotated%20Sorted%20Array/</url>
      <content type="html"><![CDATA[<p><img src="http://oj8x3nb07.bkt.clouddn.com/Blog/Search%20in%20Rotated%20Sorted%20Array.jpg" alt=""></p>
]]></content>
      
        <categories>
            
            <category> Binary Search </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Find Minimum in Rotated Sorted Array I-II]]></title>
      <url>/2018/04/22/Find%20Minimum%20in%20Rotated%20Sorted%20Array%20I-II/</url>
      <content type="html"><![CDATA[<p><img src="http://oj8x3nb07.bkt.clouddn.com/Blog/Find%20Minimum%20in%20Rotated%20Sorted%20Array%20I-II.jpg" alt=""></p>
]]></content>
      
        <categories>
            
            <category> Binary Search </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Remove Nth Node From End of List]]></title>
      <url>/2018/04/21/Remove%20Nth%20Node%20From%20End%20of%20List/</url>
      <content type="html"><![CDATA[<p><img src="http://oj8x3nb07.bkt.clouddn.com/Blog/Remove%20Nth%20Node%20From%20End%20of%20List.jpg" alt=""></p>
]]></content>
      
        <categories>
            
            <category> Two Pointer </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Minimum Window Substring]]></title>
      <url>/2018/04/15/Minimum%20Window%20Substring/</url>
      <content type="html"><![CDATA[<p><img src="http://oj8x3nb07.bkt.clouddn.com/Blog/Minimum%20Window%20Substring.jpg" alt=""></p>
]]></content>
      
        <categories>
            
            <category> Two Pointer </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Minimum Size Subarray Sum]]></title>
      <url>/2018/04/14/Minimum%20Size%20Subarray%20Sum/</url>
      <content type="html"><![CDATA[<p><img src="http://oj8x3nb07.bkt.clouddn.com/Blog/Minimum%20Size%20Subarray%20Sum.jpg" alt=""></p>
]]></content>
      
        <categories>
            
            <category> Two Pointer </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Kth Largest Element]]></title>
      <url>/2018/04/08/Kth%20Largest%20Element/</url>
      <content type="html"><![CDATA[<p><img src="http://oj8x3nb07.bkt.clouddn.com/Blog/Kth%20Largest%20Element2.jpg" alt=""></p>
]]></content>
      
        <categories>
            
            <category> Two Pointer </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Valid Palindrome]]></title>
      <url>/2018/04/07/Valid%20Palindrome/</url>
      <content type="html"><![CDATA[<p><img src="http://oj8x3nb07.bkt.clouddn.com/Blog/Valid%20Palindrome.jpg" alt=""></p>
]]></content>
      
        <categories>
            
            <category> Two Pointer </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Sort Letters by Case]]></title>
      <url>/2018/04/01/Sort%20Letters%20by%20Case/</url>
      <content type="html"><![CDATA[<p><img src="http://oj8x3nb07.bkt.clouddn.com/Blog/Sort%20Letters%20by%20Case.jpg" alt=""></p>
]]></content>
      
        <categories>
            
            <category> Two Pointer </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Partition Array by Odd and Even]]></title>
      <url>/2018/03/31/Partition%20Array%20by%20Odd%20and%20Even/</url>
      <content type="html"><![CDATA[<p><img src="http://oj8x3nb07.bkt.clouddn.com/Blog/Partition%20Array%20by%20Odd%20and%20Even.jpg" alt=""></p>
]]></content>
      
        <categories>
            
            <category> Two Pointer </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[RemoveNodeinBinaryTree]]></title>
      <url>/2018/03/28/RemoveNodeinBinaryTree/</url>
      <content type="html"><![CDATA[<p><img src="http://oj8x3nb07.bkt.clouddn.com/image/jpg/BinaryTreeRemoveNodeinBinarySearchTree.jpg" alt=""></p>
]]></content>
      
        <categories>
            
            <category> BinaryTree </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Sort Colors]]></title>
      <url>/2018/03/25/Sort%20Colors/</url>
      <content type="html"><![CDATA[<p><img src="http://oj8x3nb07.bkt.clouddn.com/Blog/Sort%20Colors.jpg" alt=""></p>
]]></content>
      
        <categories>
            
            <category> Two Pointer </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Partition Array]]></title>
      <url>/2018/03/24/Partition%20Array/</url>
      <content type="html"><![CDATA[<p><img src="http://oj8x3nb07.bkt.clouddn.com/Blog/Partition%20Array.jpg" alt=""></p>
]]></content>
      
        <categories>
            
            <category> Two Pointer </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Container With Most Water]]></title>
      <url>/2018/03/18/Container%20With%20Most%20Water/</url>
      <content type="html"><![CDATA[<p><img src="http://oj8x3nb07.bkt.clouddn.com/Blog/Container%20With%20Most%20Water%20.jpg" alt=""></p>
]]></content>
      
        <categories>
            
            <category> Two Pointer </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Trapping Rain Water]]></title>
      <url>/2018/03/17/Trapping%20Rain%20Water/</url>
      <content type="html"><![CDATA[<p><img src="http://oj8x3nb07.bkt.clouddn.com/Blog/Trapping%20Rain%20Water.jpg" alt=""></p>
]]></content>
      
        <categories>
            
            <category> Two Pointer </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Triangle Count]]></title>
      <url>/2018/03/11/Triangle%20Count/</url>
      <content type="html"><![CDATA[<p><img src="http://oj8x3nb07.bkt.clouddn.com/Blog/Triangle%20Count.jpg" alt=""></p>
]]></content>
      
        <categories>
            
            <category> Two Pointer </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Two SumII]]></title>
      <url>/2018/03/10/Two%20SumII/</url>
      <content type="html"><![CDATA[<p><img src="http://oj8x3nb07.bkt.clouddn.com/Blog/Two%20SumII.jpg" alt=""></p>
]]></content>
      
        <categories>
            
            <category> Two Pointer </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[3Sum]]></title>
      <url>/2018/03/04/3Sum/</url>
      <content type="html"><![CDATA[<p><img src="http://oj8x3nb07.bkt.clouddn.com/Blog/3Sum.jpg" alt=""></p>
]]></content>
      
        <categories>
            
            <category> Two Pointer </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[4Sum]]></title>
      <url>/2018/03/03/4Sum/</url>
      <content type="html"><![CDATA[<p><img src="http://oj8x3nb07.bkt.clouddn.com/Blog/4Sum.jpg" alt=""></p>
]]></content>
      
        <categories>
            
            <category> Two Pointer </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[3Sum Closest]]></title>
      <url>/2018/02/25/3Sum%20Closest/</url>
      <content type="html"><![CDATA[<p><img src="http://oj8x3nb07.bkt.clouddn.com/Blog/3Sum%20Closest.jpg" alt=""></p>
]]></content>
      
        <categories>
            
            <category> Two Pointer </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Copy Books]]></title>
      <url>/2018/02/24/Copy%20Books/</url>
      <content type="html"><![CDATA[<p><img src="http://oj8x3nb07.bkt.clouddn.com/Blog/Copy%20Books.jpg" alt=""></p>
]]></content>
      
        <categories>
            
            <category> Binary Search </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[maximum number in mountain sequence]]></title>
      <url>/2018/02/18/maximum%20number%20in%20mountain%20sequence/</url>
      <content type="html"><![CDATA[<p><img src="http://oj8x3nb07.bkt.clouddn.com/Blog/maximum%20number%20in%20mountain%20sequence.jpg" alt=""></p>
]]></content>
      
        <categories>
            
            <category> Binary Search </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Search in a big sorted array]]></title>
      <url>/2018/02/17/Search%20in%20a%20big%20sorted%20array/</url>
      <content type="html"><![CDATA[<p><img src="http://oj8x3nb07.bkt.clouddn.com/Blog/Search%20in%20a%20big%20sorted%20array.jpg" alt=""></p>
]]></content>
      
        <categories>
            
            <category> Binary Search </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Search insert Position]]></title>
      <url>/2018/02/10/Search%20insert%20Position/</url>
      <content type="html"><![CDATA[<p><img src="http://oj8x3nb07.bkt.clouddn.com/Blog/Search%20insert%20Position%20.jpg" alt=""></p>
]]></content>
      
        <categories>
            
            <category> Binary Search </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Search a -2d-matrix]]></title>
      <url>/2018/02/04/Search%20a%20-2d-matrix/</url>
      <content type="html"><![CDATA[<p><img src="http://oj8x3nb07.bkt.clouddn.com/Blog/Search%20a%20-2d-matrix.png" alt=""></p>
]]></content>
      
        <categories>
            
            <category> Binary Search </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Classical Binary Search]]></title>
      <url>/2018/02/03/Classical%20Binary%20Search/</url>
      <content type="html"><![CDATA[<p><img src="http://oj8x3nb07.bkt.clouddn.com/Blog/Classical%20Binary%20Search.jpg" alt=""></p>
]]></content>
      
        <categories>
            
            <category> Binary Search </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[网络通信的底层开发-服务端]]></title>
      <url>/2018/01/29/ServerDevelopment/</url>
      <content type="html"><![CDATA[<p><img src="http://oj8x3nb07.bkt.clouddn.com/Blog/ServerDevelopment1.jpg" alt=""></p>
<h1 id="ServerStart-Class"><a href="#ServerStart-Class" class="headerlink" title="ServerStart Class"></a>ServerStart Class</h1><hr>
<pre><code>using System;
using System.Collections.Generic;
using System.Linq;
using System.Net;
using System.Net.Sockets;
using System.Text;
using System.Threading;
using System.Threading.Tasks;

namespace NetFrame
{
   public class ServerStart
    {
       Socket server;//服务器socket监听对象
       int maxClient;//最大客户端连接数
       Semaphore acceptClients;
       UserTokenPool pool;

       public LengthEncode LE;
       public LengthDecode LD;
       public encode encode;
       public decode decode;
       /// &lt;summary&gt;
       /// 初始化通信监听
       /// &lt;/summary&gt;
       /// &lt;param name=&quot;port&quot;&gt;监听端口&lt;/param&gt;
       public ServerStart(int max) {
           //实例化监听对象
           server = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
           //设定服务器最大连接人数
           maxClient = max;
           //创建连接池
           pool = new UserTokenPool(max);
           //连接信号量
           acceptClients = new Semaphore(max, max);
           for (int i = 0; i &lt; max; i++) {
               UserToken token = new UserToken();
               //初始化token信息               
               token.receiveSAEA.Completed += new EventHandler&lt;SocketAsyncEventArgs&gt;(IO_Comleted);               
               token.sendSAEA.Completed += new EventHandler&lt;SocketAsyncEventArgs&gt;(IO_Comleted);
               token.LD = LD;
               token.LE = LE;
               token.encode = encode;
               token.decode = decode;
               token.sendProcess = ProcessSend;

               pool.push(token);
           }
       }

       public void Start(int port) {
           //监听当前服务器网卡所有可用IP地址的port端口
           // 外网IP  内网IP192.168.x.x 本机IP一个127.0.0.1
           server.Bind(new IPEndPoint(IPAddress.Any, port));
           //置于监听状态
           server.Listen(10);
           StartAccept(null);
       }
       /// &lt;summary&gt;
       /// 开始客户端连接监听
       /// &lt;/summary&gt;
       public void StartAccept(SocketAsyncEventArgs e) {
           //如果当前传入为空  说明调用新的客户端连接监听事件 否则的话 移除当前客户端连接
           if (e == null)
           {
               e = new SocketAsyncEventArgs();
               e.Completed += new EventHandler&lt;SocketAsyncEventArgs&gt;(Accept_Comleted);
           }
           else {
               e.AcceptSocket = null;
           }
           //信号量-1
           acceptClients.WaitOne();
           bool result= server.AcceptAsync(e);
           //判断异步事件是否挂起  没挂起说明立刻执行完成  直接处理事件 否则会在处理完成后触发Accept_Comleted事件
           if (!result) {
               ProcessAccept(e);
           }
       }

       public void ProcessAccept(SocketAsyncEventArgs e) {
           //从连接对象池取出连接对象 供新用户使用
           UserToken token = pool.pop();
           token.conn = e.AcceptSocket;
           //TODO 通知应用层 有客户端连接

           //开启消息到达监听
           StartReceive(token);
           //释放当前异步对象
           StartAccept(e);
       }

       public void Accept_Comleted(object sender, SocketAsyncEventArgs e) {
           ProcessAccept(e);
       }

       public void StartReceive(UserToken token) {
           //用户连接对象 开启异步数据接收
           bool result= token.conn.ReceiveAsync(token.receiveSAEA);
           //异步事件是否挂起
           if (!result)
           {
               ProcessReceive(token.receiveSAEA);
           }
       }

       public void IO_Comleted(object sender, SocketAsyncEventArgs e)
       {
           if (e.LastOperation == SocketAsyncOperation.Receive)
           {
               ProcessReceive(e);
           }
           else {
               ProcessSend(e);
           }
       }

       public void ProcessReceive(SocketAsyncEventArgs e) {
           UserToken token= e.UserToken as UserToken;
           //判断网络消息接收是否成功
           if (token.receiveSAEA.BytesTransferred &gt; 0 &amp;&amp; token.receiveSAEA.SocketError == SocketError.Success)
           {
               byte[] message = new byte[token.receiveSAEA.BytesTransferred];
               //将网络消息拷贝到自定义数组
               Buffer.BlockCopy(token.receiveSAEA.Buffer, 0, message, 0, token.receiveSAEA.BytesTransferred);
               //处理接收到的消息
               token.receive(message);
               StartReceive(token);
           }
           else {
               if (token.receiveSAEA.SocketError != SocketError.Success)
               {
                   ClientClose(token, token.receiveSAEA.SocketError.ToString());
               }
               else {
                   ClientClose(token, &quot;客户端主动断开连接&quot;);
               }
           }
       }
       public void ProcessSend(SocketAsyncEventArgs e) {
           UserToken token = e.UserToken as UserToken;
           if (e.SocketError != SocketError.Success)
           {
               ClientClose(token, e.SocketError.ToString());
           }
           else { 
            //消息发送成功，回调成功
               token.writed();
           }
       }

       /// &lt;summary&gt;
       /// 客户端断开连接
       /// &lt;/summary&gt;
       /// &lt;param name=&quot;token&quot;&gt; 断开连接的用户对象&lt;/param&gt;
       /// &lt;param name=&quot;error&quot;&gt;断开连接的错误编码&lt;/param&gt;
       public void ClientClose(UserToken token,string error) {
           if (token.conn != null) {
               lock (token) { 
                //通知应用层面 客户端断开连接了
                   token.Close();
                   //加回一个信号量，供其它用户使用
                   pool.push(token);
                   acceptClients.Release();                   
               }
           }
       }
    }
}
</code></pre><h1 id="UserToken-Class"><a href="#UserToken-Class" class="headerlink" title="UserToken Class"></a>UserToken Class</h1><hr>
<pre><code>using System;
using System.Collections.Generic;
using System.Linq;
using System.Net.Sockets;
using System.Text;
using System.Threading.Tasks;

namespace NetFrame
{
    /// &lt;summary&gt;
    /// 用户连接信息对象
    /// &lt;/summary&gt;
   public class UserToken
    {
       /// &lt;summary&gt;
       /// 用户连接
       /// &lt;/summary&gt;
       public Socket conn;
       //用户异步接收网络数据对象
       public SocketAsyncEventArgs receiveSAEA;
       //用户异步发送网络数据对象
       public SocketAsyncEventArgs sendSAEA;

       public LengthEncode LE;
       public LengthDecode LD;
       public encode encode;
       public decode decode;


       public delegate void SendProcess(SocketAsyncEventArgs e);

       public SendProcess sendProcess;

       List&lt;byte&gt; cache = new List&lt;byte&gt;();

       private bool isReading = false;
       private bool isWriting = false;
       Queue&lt;byte[]&gt; writeQueue = new Queue&lt;byte[]&gt;();

       public UserToken() {
           receiveSAEA = new SocketAsyncEventArgs();
           sendSAEA = new SocketAsyncEventArgs();
           receiveSAEA.UserToken = this;
           sendSAEA.UserToken = this;
       }
       //网络消息到达
       public void receive(byte[] buff) {
           //将消息写入缓存
           cache.AddRange(buff);
           if (!isReading)
           {
               isReading = true;
               onData();
           }
       }
       //缓存中有数据处理
       void onData() {
           //解码消息存储对象
           byte[] buff = null;
           //当粘包解码器存在的时候 进行粘包处理
           if (LD != null)
           {
               buff = LD(ref cache);
               //消息未接收全 退出数据处理 等待下次消息到达
               if (buff == null) { isReading = false; return; }
           }
           else {
               //缓存区中没有数据 直接跳出数据处理 等待下次消息到达
               if (cache.Count == 0) { isReading = false; return; }
           }
           //反序列化方法是否存在
           if (decode == null) { throw new Exception(&quot;message decode process is null&quot;); }
           //进行消息反序列化
           object message = decode(buff);
           //TODO 通知应用层 有消息到达

           //尾递归 防止在消息处理过程中 有其他消息到达而没有经过处理
           onData();
       }

       public void write(byte[] value) {
           if (conn == null) {
               //此连接已经断开了
               return;
           }
           writeQueue.Enqueue(value);
           if (!isWriting) {
               isWriting = true;
               onWrite();
           }
       }

       public void onWrite() {
           //判断发送消息队列是否有消息
           if (writeQueue.Count == 0) { isWriting = false; return; }
           //取出第一条待发消息
           byte[] buff = writeQueue.Dequeue();
           //设置消息发送异步对象的发送数据缓冲区数据
           sendSAEA.SetBuffer(buff, 0, buff.Length);
           //开启异步发送
           bool result = conn.SendAsync(sendSAEA);
           //是否挂起
           if (!result) {
               sendProcess(sendSAEA);
           }
       }

       public void writed() {
           //与onData尾递归同理
           onWrite();
       }
       public void Close() {
           try
           {
               writeQueue.Clear();
               cache.Clear();
               isReading = false;
               isWriting = false;
               conn.Shutdown(SocketShutdown.Both);
               conn.Close();
               conn = null;
           }
           catch (Exception e) {
               Console.WriteLine(e.Message);
           }
       }
    }
}
</code></pre><h1 id="UserTokenPool"><a href="#UserTokenPool" class="headerlink" title="UserTokenPool"></a>UserTokenPool</h1><hr>
<pre><code>using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace NetFrame
{
   public class UserTokenPool
    {
       private Stack&lt;UserToken&gt; pool; //后进先去的原则

       public UserTokenPool(int max) {
           pool = new Stack&lt;UserToken&gt;(max);
       }
       /// &lt;summary&gt;
       /// 取出一个连接对象 --创建连接
       /// &lt;/summary&gt;
       public UserToken pop() {

           return pool.Pop();
       }
       //插入一个连接对象---释放连接
       public void push(UserToken token) {
           if (token != null)
               pool.Push(token);
       }
       public int Size {
           get { return pool.Count; } 
       }
    }
}
</code></pre><h1 id="CodingDelegate"><a href="#CodingDelegate" class="headerlink" title="CodingDelegate"></a>CodingDelegate</h1><hr>
<pre><code>using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace NetFrame
{
    public delegate byte[] LengthEncode(byte[] value);
    public delegate byte[] LengthDecode(ref List&lt;byte&gt; value);

    public delegate byte[] encode(object value);
    public delegate object decode(byte[] value);
}
</code></pre><h1 id="LengthEncoding"><a href="#LengthEncoding" class="headerlink" title="LengthEncoding"></a>LengthEncoding</h1><hr>
<pre><code>using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace NetFrame.auto
{
   public class LengthEncoding
    {
       /// &lt;summary&gt;
       /// 粘包长度编码
       /// &lt;/summary&gt;
       /// &lt;param name=&quot;buff&quot;&gt;&lt;/param&gt;
       /// &lt;returns&gt;&lt;/returns&gt;
       public static byte[] encode(byte[] buff) {
           MemoryStream ms = new MemoryStream();//创建内存流对象
           BinaryWriter sw = new BinaryWriter(ms);//写入二进制对象流
           //写入消息长度
           sw.Write(buff.Length);
           //写入消息体
           sw.Write(buff);
           byte[] result = new byte[ms.Length];
           Buffer.BlockCopy(ms.GetBuffer(), 0, result, 0, (int)ms.Length);
           sw.Close();
           ms.Close();
           return result;

       }
       /// &lt;summary&gt;
       /// 粘包长度解码
       /// &lt;/summary&gt;
       /// &lt;param name=&quot;cache&quot;&gt;&lt;/param&gt;
       /// &lt;returns&gt;&lt;/returns&gt;
       public static byte[] decode(ref List&lt;byte&gt; cache) {
           if (cache.Count &lt; 4) return null;

           MemoryStream ms = new MemoryStream(cache.ToArray());//创建内存流对象，并将缓存数据写入进去
           BinaryReader br = new BinaryReader(ms);//二进制读取流
           int length = br.ReadInt32();//从缓存中读取int型消息体长度
           //如果消息体长度 大于缓存中数据长度 说明消息没有读取完 等待下次消息到达后再次处理
           if (length &gt; ms.Length - ms.Position) {
               return null;
           }
           //读取正确长度的数据
           byte[] result = br.ReadBytes(length);
           //清空缓存
           cache.Clear();
           //将读取后的剩余数据写入缓存
           cache.AddRange(br.ReadBytes((int)(ms.Length - ms.Position)));
           br.Close();
           ms.Close();
           return result;
       }
    }
}
</code></pre>]]></content>
      
        <categories>
            
            <category> Server </category>
            
        </categories>
        
        
    </entry>
    
  
  
    
  
</search>
