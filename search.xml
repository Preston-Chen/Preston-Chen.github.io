<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[Linked List Cycle]]></title>
      <url>/2019/01/19/LinkedList/Linked%20List%20Cycle/</url>
      <content type="html"><![CDATA[<p><br><font color="#002060" size="6" face="Calibri"><strong>Question：Linked List Cycle</strong></font><br></p>
<font color="#002060" size="5" face="Calibri"><strong>Description</strong></font>

<p>Given a linked list, determine if it has a cycle in it.</p>
<font color="#002060" size="5" face="Calibri"><strong>Example</strong></font>

<p>Given -21-&gt;10-&gt;4-&gt;5, tail connects to node index 1, return true</p>
<font color="#002060" size="5" face="Calibri"><strong>Challenge</strong></font>

<p>Follow up:</p>
<p>Can you solve it without using extra space?</p>
<font color="#002060" size="5" face="Calibri"><strong>Thinking</strong></font>

<p><img src="https://i.imgur.com/1pIaLkA.png" alt=""></p>
<font color="#002060" size="5" face="Calibri"><strong>Coding</strong></font>

<pre><code>/**
 * Definition for ListNode.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int val) {
 *         this.val = val;
 *         this.next = null;
 *     }
 * }
 */

public class Solution {
    /*
     * @param head: The first node of linked list.
     * @return: True if it has a cycle, or false
     */
    public Boolean hasCycle(ListNode head) 
    {   //Check the Corner Case 
        if (head == null || head.next == null) 
        {
            return false;
        }

        ListNode fast, slow;
        fast = head.next;
        slow = head;
        while (fast != slow) 
        {   //如果快指针走出了,就代表没有循环部分
            if(fast==null || fast.next==null)
                return false;
            fast = fast.next.next;
            slow = slow.next;
        } 
        return true; //相遇就代表有循环部分
    }
}
</code></pre><font color="#002060" size="5" face="Calibri"><strong>Reference</strong></font>

<p>JiuZhang. (2018). Copy List with Random Pointer. Retrieved from: <a href="https://www.jiuzhang.com/solution/linked-list-cycle/" target="_blank" rel="noopener">https://www.jiuzhang.com/solution/linked-list-cycle/</a></p>
]]></content>
      
        <categories>
            
            <category> LinkedList </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Remove Duplicates from Sorted List II]]></title>
      <url>/2019/01/19/LinkedList/Remove%20Duplicates%20from%20Sorted%20List%20II/</url>
      <content type="html"><![CDATA[<p><br><font color="#002060" size="6" face="Calibri"><strong>Question：Remove Duplicates from Sorted List II</strong></font><br></p>
<font color="#002060" size="5" face="Calibri"><strong>Description</strong></font>

<p>Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list.</p>
<font color="#002060" size="5" face="Calibri"><strong>Example</strong></font>

<p>Given 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5, return 1-&gt;2-&gt;5.<br>Given 1-&gt;1-&gt;1-&gt;2-&gt;3, return 2-&gt;3.</p>
<font color="#002060" size="5" face="Calibri"><strong>Thinking</strong></font>

<p><img src="https://i.imgur.com/jayw04d.png" alt=""></p>
<font color="#002060" size="5" face="Calibri"><strong>Coding</strong></font>

<pre><code>/**
 * Definition for ListNode
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */

public class Solution {
    /**
     * @param head: head is the head of the linked list
     * @return: head of the linked list
     */
    public ListNode deleteDuplicates(ListNode head) 
    {   //Check the Corner Case 
        if (head == null || head.next == null)
        {
            return head;
        }

        ListNode dummy = new ListNode(0);
        dummy.next = head;

        //prev VS curt 
        ListNode prev = dummy;
        ListNode curt = head;
        while (curt != null)  //遍历整个列表
        {
            if(curt.next != null &amp;&amp; curt.val == curt.next.val)  //下一个元素不能为空，且下一个元素等于当前元素
            {
                int val = curt.val;  //把目标元素锁定
                while(curt != null &amp;&amp; curt.val == val) //一次性找到所有相同元素(怪物)
                {
                    curt = curt.next;
                }
                //curt == null or curt.val != val
                prev.next = curt;    //然后师傅,一次性把这些怪物 (元素)清除掉
            }
            else //下一个元素不等于当前元素时 (师傅 和 徒弟一起往前走)
            {
                prev = curt;
                curt = curt.next;
            }
        }

        return dummy.next; //因为我们一直没有改变列表的结构,直接返回就行了
    }
}
</code></pre><font color="#002060" size="5" face="Calibri"><strong>Reference</strong></font>

<p>JiuZhang. (2018). Copy List with Random Pointer. Retrieved from: <a href="https://www.jiuzhang.com/solution/remove-duplicates-from-sorted-list-ii/" target="_blank" rel="noopener">https://www.jiuzhang.com/solution/remove-duplicates-from-sorted-list-ii/</a></p>
]]></content>
      
        <categories>
            
            <category> LinkedList </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Merge K Sorted Lists]]></title>
      <url>/2019/01/19/LinkedList/Merge%20K%20Sorted%20Lists/</url>
      <content type="html"><![CDATA[<p><br><font color="#002060" size="6" face="Calibri"><strong>Question：Merge K Sorted Lists</strong></font><br></p>
<font color="#002060" size="5" face="Calibri"><strong>Description</strong></font>

<p>Merge k sorted linked lists and return it as one sorted list.</p>
<p>Analyze and describe its complexity.</p>
<font color="#002060" size="5" face="Calibri"><strong>Example</strong></font>

<p>Given lists:</p>
<pre><code>[
  2-&gt;4-&gt;null,
  null,
  -1-&gt;null
],
</code></pre><p>return -1-&gt;2-&gt;4-&gt;null.</p>
<font color="#002060" size="5" face="Calibri"><strong>Thinking</strong></font>

<p><img src="https://i.imgur.com/kuj4fNQ.png" alt=""></p>
<font color="#002060" size="5" face="Calibri"><strong>Coding - Divide &amp; Conquer  ( NlogK )</strong></font>

<pre><code>    /**
 * Definition for ListNode.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int val) {
 *         this.val = val;
 *         this.next = null;
 *     }
 * }
 */ 
public class Solution {
    /**
     * @param lists: a list of ListNode
     * @return: The head of one sorted list.
     */
    public ListNode mergeKLists(List&lt;ListNode&gt; lists) 
    {  
        //Check the Corner Case 
        if (lists.size() == 0) 
        {
            return null;
        }
        return mergeHelper(lists, 0, lists.size() - 1);
    }

    //把所有的列表作为参数往里面传
    private ListNode mergeHelper(List&lt;ListNode&gt; lists, int start, int end) 
    {
        if (start == end) //递归的出口
        {
            return lists.get(start);
        }

        int mid = start + (end - start) / 2;   //取一个中点
        ListNode left = mergeHelper(lists, start, mid);  //把左半部分合并成一个
        ListNode right = mergeHelper(lists, mid + 1, end); //把右半部分合并成一个
        return mergeTwoLists(left, right);  //然后把它们左右部分的两个结果合并在一起
    }

    private ListNode mergeTwoLists(ListNode list1, ListNode list2) 
    {
        ListNode dummy = new ListNode(0);
        ListNode tail = dummy;
        while (list1 != null &amp;&amp; list2 != null) 
        {
            if (list1.val &lt; list2.val) 
            {
                tail.next = list1;
                tail = list1;
                list1 = list1.next;
            } 
            else 
            {
                tail.next = list2;
                tail = list2;
                list2 = list2.next;
            }
        }
        if (list1 != null) 
        {
            tail.next = list1;
        } 
        else 
        {
            tail.next = list2;
        }

        return dummy.next;
    }
}
</code></pre><font color="#002060" size="5" face="Calibri"><strong>Coding - Heap (Nlogk)</strong></font>

<pre><code>/**
 * Definition for ListNode.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int val) {
 *         this.val = val;
 *         this.next = null;
 *     }
 * }
 */ 
public class Solution {
    /**
     * @param lists: a list of ListNode
     * @return: The head of one sorted list.
     */
    private Comparator&lt;ListNode&gt; ListNodeComparator = new Comparator&lt;ListNode&gt;() 
    {
        public int compare(ListNode left, ListNode right)  //谁小 谁在前面
        {
            return left.val - right.val;
        }
    };


    public ListNode mergeKLists(List&lt;ListNode&gt; lists) 
    {   //Check the Corner Case 
        if (lists == null || lists.size() == 0) 
        {
            return null;
        }

        Queue&lt;ListNode&gt; heap = new PriorityQueue&lt;ListNode&gt;(lists.size(), ListNodeComparator);
        for (int i = 0; i &lt; lists.size(); i++) 
        {
            if (lists.get(i) != null) 
            {
                heap.add(lists.get(i)); //放进优先队列里面
            }
        }

        ListNode dummy = new ListNode(0);
        ListNode tail = dummy;
        while (!heap.isEmpty()) 
        {
            ListNode head = heap.poll(); //每一次都从这个heap里面拿一个最少的出来
            tail.next = head;  //拿出来后让它 在tail这里排队
            tail = head;
            if (head.next != null) 
            {
                heap.add(head.next); //拿出来后,后面如果还有元素,就会加入新的优先队列里面
            }
        }
        return dummy.next;
    }
}
</code></pre><font color="#002060" size="5" face="Calibri"><strong>Coding - Merge two by two</strong></font>

<pre><code>/**
 * Definition for ListNode.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int val) {
 *         this.val = val;
 *         this.next = null;
 *     }
 * }
 */ 
public class Solution {
    /**
     * @param lists: a list of ListNode
     * @return: The head of one sorted list.
     */

    public ListNode mergeKLists(List&lt;ListNode&gt; lists) 
    {  
        if (lists == null || lists.size() == 0) 
        {
            return null;
        }

        while (lists.size() &gt; 1) 
        {
            List&lt;ListNode&gt; new_lists = new ArrayList&lt;ListNode&gt;();
            for (int i = 0; i + 1 &lt; lists.size(); i += 2) 
            {
                ListNode merged_list = merge(lists.get(i), lists.get(i+1));
                new_lists.add(merged_list);
            }
            if (lists.size() % 2 == 1) 
            {
                new_lists.add(lists.get(lists.size() - 1));
            }
            lists = new_lists;
        }

        return lists.get(0);
    }

    private ListNode merge(ListNode a, ListNode b) 
    {
        ListNode dummy = new ListNode(0);
        ListNode tail = dummy;
        while (a != null &amp;&amp; b != null) 
        {
            if (a.val &lt; b.val) 
            {
                tail.next = a;
                a = a.next;
            } 
            else 
            {
                tail.next = b;
                b = b.next;
            }
            tail = tail.next;
        }

        if (a != null) 
        {
            tail.next = a;
        } 
        else 
        {
            tail.next = b;
        }

        return dummy.next;
    }
}
</code></pre><font color="#002060" size="5" face="Calibri"><strong>Reference</strong></font>

<p>JiuZhang. (2018). Copy List with Random Pointer. Retrieved from: <a href="https://www.jiuzhang.com/solution/merge-k-sorted-lists/" target="_blank" rel="noopener">https://www.jiuzhang.com/solution/merge-k-sorted-lists/</a></p>
]]></content>
      
        <categories>
            
            <category> LinkedList </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Copy List with Random Pointer]]></title>
      <url>/2019/01/19/LinkedList/Copy%20List%20with%20Random%20Pointer/</url>
      <content type="html"><![CDATA[<p><br><font color="#002060" size="6" face="Calibri"><strong>Question：Copy List with Random Pointer</strong></font><br></p>
<font color="#002060" size="5" face="Calibri"><strong>Description</strong></font>

<p>A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null.</p>
<p>Return a deep copy of the list.</p>
<font color="#002060" size="5" face="Calibri"><strong>Challenge</strong></font>

<p>Could you solve it with O(1) space?</p>
<font color="#002060" size="5" face="Calibri"><strong>Thinking HashMap Version</strong></font><br><img src="https://i.imgur.com/xibMPVs.png" alt=""><br><br><br><font color="#002060" size="5" face="Calibri"><strong>Coding</strong></font>

<pre><code>    /**
 * Definition for singly-linked list with a random pointer.
 * class RandomListNode {
 *     int label;
 *     RandomListNode next, random;
 *     RandomListNode(int x) { this.label = x; }
 * };
 */
public class Solution {
     * @param head: The head of linked list with a random pointer.
     * @return: A new head of a deep copy of the list.
    public RandomListNode copyRandomList(RandomListNode head) 
    {
        if (head == null) 
        {
            return null;
        }

        HashMap&lt;RandomListNode, RandomListNode&gt; map = new HashMap&lt;RandomListNode, RandomListNode&gt;();
        RandomListNode dummy = new RandomListNode(0);
        RandomListNode pre = dummy, newNode;
        while (head != null) 
        {
            if (map.containsKey(head)) 
            {
                newNode = map.get(head);
            } 
            else 
            {
                newNode = new RandomListNode(head.label);
                map.put(head, newNode);
            }
            pre.next = newNode;

            if (head.random != null) 
            {
                if (map.containsKey(head.random)) 
                {
                    newNode.random = map.get(head.random);
                } 
                else 
                {
                    newNode.random = new RandomListNode(head.random.label);
                    map.put(head.random, newNode.random);
                }
            }

            pre = newNode;
            head = head.next;
        }

        return dummy.next;
    }
}
</code></pre><font color="#002060" size="5" face="Calibri"><strong>Thinking No HashMap Version</strong></font><br><img src="https://i.imgur.com/YVLg8UV.png" alt=""><br><br><font color="#002060" size="5" face="Calibri"><strong>Coding</strong></font>

<pre><code>/**
 * Definition for singly-linked list with a random pointer.
 * class RandomListNode {
 *     int label;
 *     RandomListNode next, random;
 *     RandomListNode(int x) { this.label = x; }
 * };
 */
public class Solution {
    /**
     * @param head: The head of linked list with a random pointer.
     * @return: A new head of a deep copy of the list.
     */
    private void copyNext(RandomListNode head) 
    {
        while (head != null) 
        {
            RandomListNode newNode = new RandomListNode(head.label);
            newNode.random = head.random;
            newNode.next = head.next;
            head.next = newNode;      //每个元素复制多一份在列表中
            head = head.next.next;    //当前的下一个,下一个才是  原来链表的下一个
        }
    }

    private void copyRandom(RandomListNode head) 
    {
        while (head != null) 
        {
            if (head.next.random != null) 
            {
                head.next.random = head.random.next;
            }
            head = head.next.next;
        }
    }

    private RandomListNode splitList(RandomListNode head) 
    {
        RandomListNode newHead = head.next;
        while (head != null) 
        {
            RandomListNode temp = head.next;
            head.next = temp.next;
            head = head.next;
            if (temp.next != null) 
            {
                temp.next = temp.next.next;
            }
        }
        return newHead;
    }

    public RandomListNode copyRandomList(RandomListNode head) 
    {
        // write your code here
        if (head == null) 
        {
            return null;
        }
        copyNext(head);         //把列表复制多一份,在同一个列表中
        copyRandom(head);       //然后再去复制随机的指针
        return splitList(head); //然后把新new出来的节点抽离出来
    }
}
</code></pre><font color="#002060" size="5" face="Calibri"><strong>Reference</strong></font>

<p>JiuZhang. (2018). Copy List with Random Pointer. Retrieved from: <a href="https://www.jiuzhang.com/solution/copy-list-with-random-pointer/" target="_blank" rel="noopener">https://www.jiuzhang.com/solution/copy-list-with-random-pointer/</a></p>
]]></content>
      
        <categories>
            
            <category> LinkedList </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Partition List]]></title>
      <url>/2019/01/19/LinkedList/Partition%20List/</url>
      <content type="html"><![CDATA[<p><br><font color="#002060" size="6" face="Calibri"><strong>Question：Partition List</strong></font><br></p>
<font color="#002060" size="5" face="Calibri"><strong>Description</strong></font>

<p>Given a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x.</p>
<p>You should preserve the original relative order of the nodes in each of the two partitions.</p>
<font color="#002060" size="5" face="Calibri"><strong>Example</strong></font>

<p>Given 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2-&gt;null and x = 3,</p>
<p>return 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5-&gt;null.</p>
<font color="#002060" size="5" face="Calibri"><strong>Thinking</strong></font>

<p><br><font color="#000000" size="3.5" face="华文楷体">给出一个列表,和一个x 值 (把所有大于/等于x的值放在右边, 小于x的值放在左边 )</font><br></p>
<font color="#002060" size="5" face="Calibri"><strong>Coding</strong></font>

<pre><code>Coding
/**
 * Definition for ListNode
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */

public class Solution {
    /**
     * @param head: The first node of linked list
     * @param x: An integer
     * @return: A ListNode
     */
    public ListNode partition(ListNode head, int x) 
    {   //Check the Corner Case 
         if (head == null) 
         {
            return null;
        }

        ListNode leftDummy = new ListNode(0);
        ListNode rightDummy = new ListNode(0);
        ListNode left = leftDummy, right = rightDummy; //左边队伍的尾巴  和 右边队伍的尾巴

        while (head != null)  //遍历整个列表
        {
            if (head.val &lt; x) 
            {
                left.next = head;
                left = head;
            } 
            else 
            {
                right.next = head;
                right = head;
            }
            head = head.next;  //继续往下移动
        }
        //把左边队伍的尾巴  和 右边队伍的头连接在一起
        right.next = null;
        left.next = rightDummy.next;
        return leftDummy.next;
    }
}
</code></pre><font color="#002060" size="5" face="Calibri"><strong>Reference</strong></font>

<p>JiuZhang. (2018). Copy List with Random Pointer. Retrieved from: <a href="https://www.jiuzhang.com/solution/partition-list/" target="_blank" rel="noopener">https://www.jiuzhang.com/solution/partition-list/</a></p>
]]></content>
      
        <categories>
            
            <category> LinkedList </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Reverse Linked List II]]></title>
      <url>/2019/01/19/LinkedList/Reverse%20Linked%20List%20II/</url>
      <content type="html"><![CDATA[<p><br><font color="#002060" size="6" face="Calibri"><strong>Question：Reverse Linked List II</strong></font><br></p>
<font color="#002060" size="5" face="Calibri"><strong>Description</strong></font>

<p>Reverse a linked list from position m to n.<br>(Given m, n satisfy the following condition: 1 ≤ m ≤ n ≤ length of list.)</p>
<font color="#002060" size="5" face="Calibri"><strong>Example</strong></font>

<p>Given 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2 and n = 4, return 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL.</p>
<font color="#002060" size="5" face="Calibri"><strong>Challenge</strong></font>

<p>Reverse it in-place and in one-pass</p>
<font color="#002060" size="5" face="Calibri"><strong>Thinking</strong></font>

<p><img src="https://i.imgur.com/0D7uu8C.png" alt=""></p>
<font color="#002060" size="5" face="Calibri"><strong>Coding</strong></font>

<pre><code>/**
 * Definition for ListNode
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */

public class Solution {
    /**
     * @param head: ListNode head is the head of the linked list 
     * @param m: An integer
     * @param n: An integer
     * @return: The head of the reversed ListNode
     */
    public ListNode reverseBetween(ListNode head, int m, int n) {
        //Check the Corner Case 
        if (m &gt;= n || head == null) 
        {
            return head;
        }

        ListNode dummy = new ListNode(0);
        dummy.next = head;
        head = dummy;

        for (int i = 1; i &lt; m; i++) //找到M – 1 的节点 
        {
            if (head == null) 
            {
                return null;
            }
            head = head.next;
        }

        ListNode premNode = head;
        ListNode mNode = head.next;
        //然后翻转 m ~ n 之间的区域
        ListNode nNode = mNode, postnNode = mNode.next;
        for (int i = m; i &lt; n; i++) 
        {
            if (postnNode == null) 
            {
                return null;
            }
            ListNode temp = postnNode.next;
            postnNode.next = nNode;
            nNode = postnNode;   //往下移动
            postnNode = temp;
        }
        mNode.next = postnNode;  //m节点去到 n + 1节点上
        premNode.next = nNode;   //m – 1 节点去到n节点上

        return dummy.next;
    }
}
</code></pre><font color="#002060" size="5" face="Calibri"><strong>Reference</strong></font>

<p>JiuZhang. (2018). Copy List with Random Pointer. Retrieved from: <a href="https://www.jiuzhang.com/solution/reverse-linked-list-ii/" target="_blank" rel="noopener">https://www.jiuzhang.com/solution/reverse-linked-list-ii/</a></p>
]]></content>
      
        <categories>
            
            <category> LinkedList </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Intersection of Two Linked Lists]]></title>
      <url>/2019/01/19/LinkedList/Intersection%20of%20Two%20Linked%20Lists/</url>
      <content type="html"><![CDATA[<p><br><font color="#002060" size="6" face="Calibri"><strong>Question：Intersection of Two Linked Lists</strong></font><br></p>
<font color="#002060" size="5" face="Calibri"><strong>Description</strong></font>

<p>Write a program to find the node at which the intersection of two singly linked lists begins.</p>
<font color="#002060" size="5" face="Calibri"><strong>Example</strong></font>

<p>The following two linked lists:</p>
<pre><code>A:      a1 → a2
               ↘
                 c1 → c2 → c3
               ↗            
B: b1 → b2 → b3
</code></pre><p>begin to intersect at node c1.</p>
<font color="#002060" size="5" face="Calibri"><strong>Challenge</strong></font>

<p>Your code should preferably run in O(n) time and use only O(1) memory.</p>
<p><br><font color="#002060" size="5" face="Calibri"><strong>Thinking</strong></font><br></p>
<p><br><font color="#000000" size="3.5" face="华文楷体">如果两个链表没有交点，则返回null,在求交点的过程中，不可以破坏链表的结构或者修改链表数据，可以确保传入的链表A与链表B没有任何环</font><br></p>
<p><br><font color="#000000" size="3.5" face="华文楷体">虽然题目强调了不存在环，但我们可以用环的方式去做,把两个链表合在一起，如果他们有着相同的元素，则一定会在交点相遇</font><br></p>
<font color="#002060" size="5" face="Calibri"><strong>Coding</strong></font>

<pre><code>    /**
 * Definition for ListNode
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */

public class Solution {
    /**
     * @param headA: the first list
     * @param headB: the second list
     * @return: a ListNode
     */
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        //Check the Corner Case 
        if (headA == null || headB == null) {
            return null;
        }

        //获得链表A的尾巴
        ListNode node = headA;
        while (node.next != null) {
            node = node.next;
        }
        node.next = headB; //两个链表合在一起
        ListNode result = listCycleII(headA); //然后判断是否相遇 是否有环
        return result;
    }

    private ListNode listCycleII(ListNode head) {
        ListNode slow = head, fast = head.next;

        while (slow != fast) {
            if (fast == null || fast.next == null) {
                return null;
            }

            slow = slow.next;
            fast = fast.next.next;
        }

        while (head != slow.next) 
        {
            head = head.next;
            slow = slow.next;
        }

        return head;
    }
}
</code></pre><font color="#002060" size="5" face="Calibri"><strong>Reference</strong></font>

<p>JiuZhang. (2018). Copy List with Random Pointer. Retrieved from: <a href="https://www.jiuzhang.com/solution/intersection-of-two-linked-lists/" target="_blank" rel="noopener">https://www.jiuzhang.com/solution/intersection-of-two-linked-lists/</a></p>
]]></content>
      
        <categories>
            
            <category> LinkedList </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Reverse Linked List]]></title>
      <url>/2019/01/12/LinkedList/Reverse%20Linked%20List/</url>
      <content type="html"><![CDATA[<p><br><font color="#002060" size="6" face="Calibri"><strong>Question：Reverse Linked List</strong></font><br></p>
<font color="#002060" size="5" face="Calibri"><strong>Example</strong></font>

<p>For linked list 1-&gt;2-&gt;3, the reversed linked list is 3-&gt;2-&gt;1</p>
<font color="#002060" size="5" face="Calibri"><strong>Challenge</strong></font>

<p>Reverse it in-place and in one-pass</p>
<font color="#002060" size="5" face="Calibri"><strong>Thinking</strong></font>

<p><img src="https://i.imgur.com/pZVDbgt.png" alt=""></p>
<font color="#002060" size="5" face="Calibri"><strong>Coding</strong></font>

<pre><code>/**
 * Definition for ListNode
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */

public class Solution {
    /**
     * @param head: n
     * @return: The new head of reversed linked list.
     */
    public ListNode reverse(ListNode head) 
    {
        ListNode prev = null;    //反转后列表head前面是空
        ListNode curt = head;    //初始化当前Curt:为Head

        while(curt != null)      //遍历整个列表
        {
            ListNode temp = curt.next; //把下一个节点的信息存储起来
            curt.next = prev;  //当前节点赋值给前一个节点
            prev = curt;       //然后两个 prev  和 curt两个基友往下移动
            curt = temp;
        }

        return prev;
    }
}
</code></pre><font color="#002060" size="5" face="Calibri"><strong>Reference</strong></font>

<p>JiuZhang. (2018). Copy List with Random Pointer. Retrieved from: <a href="https://www.jiuzhang.com/solution/reverse-linked-list/" target="_blank" rel="noopener">https://www.jiuzhang.com/solution/reverse-linked-list/</a></p>
]]></content>
      
        <categories>
            
            <category> LinkedList </category>
            
        </categories>
        
        
    </entry>
    
  
  
    
  
</search>
